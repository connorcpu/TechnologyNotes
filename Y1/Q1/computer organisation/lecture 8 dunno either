alignment, we fucking get it the weird part was applying it to .text and .data
## I/O
bus connects CPU memory and IO
single-bus architecture
   one line, cpu and IO connected to the same line
   simple, flexible, low cost
   not scalable
   high traffic devices may starve others
duals-bus architecture
   connect memory sepretly (it causes the most trouble)
   faster
   complex
   limited scalability
north-south architecture
   CPU to north-bridge
   north-bridge to heavy users (memory PCIe)
   south-bridge to north-bridge
   i/o devices to south-bridge
modern
   put north-bridge in CPU 
   partially move south-bridge to CPU

### inside of a bus 
3 sets of lines
address lines 
   carry what location the CPU wants to access
data lines 
   carry the actual info
control lines
   how to interpret the transfer
   (read, write, clock, interrupt)

### how to address I/O
immediate value
direct m(val/loc)
register [reg]
register indirect put address into register

port-mapped ISA
   you map a single address to the device (not correct, find out what??)
   con: you have to change ISA,
   special instructions (IN OUT)
memory-mapped
   use actual memory addresses (not what we were doing before?)
   you can't access the memory at I/O addresses

Intel did not used to like memory-mapped because it took to much memory but now you can use addresses above physical mem, port is deprecated

### synchronous bus: ideal case 
bus clock clocks, usually on rising edge otherwise falling edge
address gets put on line on clock rising edge
when lines cross bus data is changed
1. let mouse know it needs to read data by putting address on bus
2. put data on data line 
3. mouse reads data from data line
### synchronus bus: realistic case
't-setup delay' happends when address is put on line but arives later
theres is delay because not instant
data can leak over to other clock cyles

### synchronus bus: multi-cycle bus
cpu would not know if the data is being sent yet so slave ready signal tells you there is data that can be read


